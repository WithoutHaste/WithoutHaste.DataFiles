<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WithoutHaste.DataFiles</name>
    </assembly>
    <members>
        <member name="T:WithoutHaste.DataFiles.ArbitraryCounter">
            <summary>
            Counts using an arbitrary set of digits.
            </summary>
            <remarks>
            Using "integers" as an analogy, Counter values cannot be negative.
            </remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.ArbitraryCounter.value">
            <summary>Current internal value.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.ArbitraryCounter.VALID_CHARACTERS">
            <summary>All valid characters, in order from smallest to largest.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.ArbitraryCounter.#ctor(System.Char[])">
            <summary>Initialize at MINIMUM_VALUE.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.ArbitraryCounter.SetValue(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.ArbitraryCounter.SetValue(System.Collections.Generic.List{System.Char})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.ArbitraryCounter.Increment(System.Collections.Generic.List{System.Char},System.Int32)">
            <summary>Increment a value.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.ArbitraryCounter.Decrement(System.Collections.Generic.List{System.Char},System.Int32)">
            <summary>Increment a value.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.ArbitraryCounter.CopyValue">
            <summary>Returns an independent copy of the value.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.ArbitraryCounter.MINIMUM_VALUE">
            <summary>Counter can never decrement below the minimum value.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.ArbitraryCounter.Value">
            <summary>Current display value.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.AlphabetCounter">
            <summary>
            Counts "A", "B", "C", ..., "Z", "AA", "AB", ..., "AZ", "BA", "BB", ...
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.AlphabetCounter.CHARACTERS">
            <summary>
            Valid characters.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.AlphabetCounter.#ctor">
            <summary>
            Initialize a counter at "A".
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.AlphabetCounter.op_Addition(WithoutHaste.DataFiles.AlphabetCounter,System.Int32)">
            <summary>Increment counter.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.AlphabetCounter.op_Subtraction(WithoutHaste.DataFiles.AlphabetCounter,System.Int32)">
            <summary>Decrement counter.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.AlphabetCounter.op_Increment(WithoutHaste.DataFiles.AlphabetCounter)">
            <summary>Increment counter by 1.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.AlphabetCounter.op_Decrement(WithoutHaste.DataFiles.AlphabetCounter)">
            <summary>Decrement counter by 1.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetBaseType">
            <summary>
            Represents a node in an inheriance hierarchy.
            Stub class: contains minimal information about the type.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetBaseType.#ctor(System.Type)">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetBaseType.Name">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetBaseType.BaseType">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetBaseType.Depth">
            <summary>Returns the inheritance distance from here to the bottom.</summary>
            <example>Class "System.Reflection.TypeInfo" has Depth = 4 because its inheritance path is "TypeInfo -> Type -> MemberInfo -> Object".</example>
            <example>Class "System.Object" has Depth = 1 because its inheritance path is just "Object".</example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentDuplicate">
            <summary>
            Represents a the <![CDATA[<duplicate cref="" />]]> tag, which means that documentation should be copied from the specified (cref) class, interface, struct, or member.
            </summary>
            <remarks>This is just a marker class. If the cref can be resolved, the duplicated comments will automatically replace this comment.</remarks>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink">
            <summary>
            Represents a link in the comments to an internal or extenal type or type.method().
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetComment">
            <summary>
            Represents a section of documentation, such as the contents of a <![CDATA[<summary></summary>]]> tag.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses top-level .Net XML documentation comments. Returns null if no comments are found.</summary>
            <returns>Returns null if the element name is not recognized.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.FromVisualStudioXml(System.String)">
            <summary>Creates a plain text comment.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.ParseSection(System.Xml.Linq.XElement)">
            <summary>Parses inner .Net XML documentation comments.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.ValidateXmlTag(System.Xml.Linq.XElement,System.String)">
            <summary>
            Throws exception on unexpected xml formats.
            </summary>
            <exception cref="T:WithoutHaste.DataFiles.XmlFormatException">XML tag does not have the expected local name, or is null</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.ValidateXmlTag(System.Xml.Linq.XElement,System.String[])">
            <summary>
            Throws exception on unexpected xml formats.
            </summary>
            <exception cref="T:WithoutHaste.DataFiles.XmlFormatException">XML tag does not have any of the expected local names, or is null</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.IsXmlTag(System.Xml.Linq.XElement,System.String)">
            <summary>
            Returns false on unexpected xml formats.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.IsXmlTag(System.Xml.Linq.XElement,System.String[])">
            <summary>
            Returns false on unexpected xml formats.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.GetTag(System.Xml.Linq.XElement)">
            <summary>
            Returns the CommentTag value that corresponds to the XElement.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetComment.ToString">
            <summary>Defaults to the CommentTag text.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetComment.Tag">
            <summary>The type of xml tag that the comment came from.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.IDotNetCommentLink">
            <summary>
            Represents anything in the comments that links to something in the assembly.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.IDotNetCommentLink.FullName">
            <summary>Return the fully qualified name of the referenced assembly element.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.CommentTag)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation tag that contains attribute cref.</summary>
            <example><![CDATA[<exception cref="Namespace.ExceptionType">nested comments and/or plain text</exception>]]></example>
            <example><![CDATA[<permission cref="Namespace.Type">nested comments and/or plain text</permission>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.FromVisualStudioXml(System.String)">
            <summary>Parses .Net XML documentation cref.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.Matches(WithoutHaste.DataFiles.DotNet.DotNetMember)">
            <summary>
            Returns true if link name matches the member name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.Name">
            <summary>Name of type or member.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink.FullName">
            <inheritdoc />
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentDuplicate.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentDuplicate.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink)">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentInherit">
            <summary>
            Represents a the <![CDATA[<inheritdoc />]]> tag, which means that documentation should be inherited for the base class, interface, struct, or member.
            </summary>
            <remarks>This is just a marker class. If the inheritance can be resolved, the inherited comments will automatically replace this comment.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentInherit.#ctor">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLinkedGroup">
            <summary>
            Represents a section of comments that is linked to a method.
            </summary>
            <example><![CDATA[<permission cref="Namespace.Type.Method()">nested comments</permission>]]></example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup">
            <summary>
            Represents a section of comments that is linked to a fully qualified type or member.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentLinkedGroup">
            <summary>
            Represents an ordered collection of comments that is linked to something in the assembly which it is documenting.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup">
            <summary>
            Represents an ordered collection of comments.
            </summary>
            <remarks>Groups may include a link to something in the assembly which these comments are documenting.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.Comments">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(WithoutHaste.DataFiles.DotNet.CommentTag)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(WithoutHaste.DataFiles.DotNet.CommentTag,WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(WithoutHaste.DataFiles.DotNet.CommentTag,WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.#ctor(WithoutHaste.DataFiles.DotNet.CommentTag,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation for any "grouping" tag.</summary>
            <example><![CDATA[<summary>nested comments and/or plain text</summary>]]></example>
            <example><![CDATA[<remarks>nested comments and/or plain text</remarks>]]></example>
            <example><![CDATA[<example>nested comments and/or plain text</example>]]></example>
            <example><![CDATA[<para>nested comments and/or plain text</para>]]></example>
            <example><![CDATA[<returns>nested comments and/or plain text</returns>]]></example>
            <example><![CDATA[<value>nested comments and/or plain text</value>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.Add(WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.Add(WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.Add(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.IsEmpty">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.Count">
            <summary>The number of comments in the group. Does not count nested comments.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentGroup.Item(System.Int32)">
            <summary>Access comments by zero-based index.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentLinkedGroup.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.IDotNetCommentLink,WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.IDotNetCommentLink,WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.IDotNetCommentLink,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentLinkedGroup.Link">
            <summary>Reference link from comments to something in the assembly.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink,WithoutHaste.DataFiles.DotNet.CommentTag,WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink,WithoutHaste.DataFiles.DotNet.CommentTag,WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink,WithoutHaste.DataFiles.DotNet.CommentTag,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation for permission or exception.</summary>
            <example><![CDATA[<permission cref="Namespace.Type.Member">nested comments</permission>]]></example>
            <example><![CDATA[<exception cref="Namespace.ExceptionType">nested comments</exception>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup.Matches(WithoutHaste.DataFiles.DotNet.DotNetMember)">
            <summary>
            Returns true if link name matches the member name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup.QualifiedLink">
            <summary>Strongly-typed link.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink,WithoutHaste.DataFiles.DotNet.CommentTag,WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink,WithoutHaste.DataFiles.DotNet.CommentTag,WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLinkedGroup.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink,WithoutHaste.DataFiles.DotNet.CommentTag,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLinkedGroup.MethodLink">
            <summary>Strongly-typed link.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetDelegate">
            <summary>
            Represents a delegate type, categorized as a method.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetMethod">
            <summary>
            Represents a method.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetMember">
            <summary>
            Represents any .Net construct that can have comments on it:
            class, interface, struct, delegate, enum, method, field, property, event, etc.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.SummaryComments">
            <summary>Comments from "summary" xml tags. Only expected as a top-level tag.</summary>
            <remarks>If there are multiple "summary" tags, their contents will be concatenated as if they were one tag.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.RemarksComments">
            <summary>Comments from "remarks" xml tags. Only expected as a top-level tag.</summary>
            <remarks>If there are multiple "remarks" tags, their contents will be concatenated as if they were one tag.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.PermissionComments">
            <summary>Comments from "permission" xml tags. Only expected as top-level tags.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.ExampleComments">
            <summary>Comments from "example" xml tags.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.ExceptionComments">
            <summary>Comments from "exception" xml tags.  Only expected as top-level tags.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.ParameterComments">
            <summary>Comments from "param" xml tags. Only expected as top-level tags.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.TypeParameterComments">
            <summary>Comments from "typeparam" xml tags. Only expected as top-level tags.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.ValueComments">
            <summary>Comments from "value" xml tags. Only expected as a top-level tag.</summary>
            <remarks>If there are multiple "value" tags, their contents will be concatenated as if they were one tag.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.ReturnsComments">
            <summary>Comments from "returns" xml tags. Only expected as a top-level tag.</summary>
            <remarks>If there are multiple "returns" tags, their contents will be concatenated as if they were one tag.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMember.FloatingComments">
            <summary>Any comments not within expected top-level tags.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.ParseVisualStudioXmlDocumentation(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation about this member.
            </summary>
            <remarks>Clears any existing comments before parsing the new ones.</remarks>
            <param name="parent">Expects the tag containing all documentation for this member.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.ResolveDuplicatedComments(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetMember},System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName})">
            <summary>
            For all "duplicate" comments, replace the comment with the duplicated comments.
            </summary>
            <param name="FindMember">Function that returns the selected member from all known members in the assembly.</param>
            <param name="pathToThisDuplicate">List of named types/members that are duplicating each other, leading to this member. Used to avoid reference loops.</param>
            <returns>Returns true if resolution is successful. Returns false if referenced member is not found, or if there is a reference loop.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.CopyComments(WithoutHaste.DataFiles.DotNet.DotNetMember)">
            <summary>
            Shallow-copies all comments from the <paramref name="original"/> member to this member.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.ClearComments">
            <summary>
            Removes all comments from member.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.ToString">
            <summary>Full name of member.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.Matches(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLink)">
            <summary>
            Returns true if member name matches the link name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMember.Matches(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup)">
            <summary>
            Returns true if member name matches the link name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetMember.Name">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetMember.HasComments">
            <summary>True when there's at least one comment on this member.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetMember.HasNoComments">
            <summary>True when there are no comments on this member.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation for method signature data.
            </summary>
            <param name="memberElement">Expects tag "member".</param>
            <example><![CDATA[<member name="M:Namespace.Type.MethodName(System.Int32,System.String)"></member>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.Is(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns true if this member's name matches the provided name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.MatchesSignature(System.Reflection.MethodInfo)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesSignature(System.Reflection.MethodInfo)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.MatchesLocalSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesLocalSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetMethod)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.MatchesArguments(System.Reflection.ParameterInfo[])">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesArguments(System.Reflection.ParameterInfo[])"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.MatchesArguments(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetParameter})">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesArguments(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetParameter})"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.AddAssemblyInfo(System.Reflection.MethodInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.GetFullListOfLocalNames">
            <summary>
            Collect full list of local names used throughout documentation.
            Includes namespaces, internal types, external types, and members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.PushClassGenericTypes(System.String[])">
            <summary>
            Update method parameter types and return type with the class's generic-type aliases.
            </summary>
            <param name="classGenericTypeAliases">Ordered list of aliases.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.op_Equality(WithoutHaste.DataFiles.DotNet.DotNetMethod,WithoutHaste.DataFiles.DotNet.DotNetMethod)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.Equals(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.op_Inequality(WithoutHaste.DataFiles.DotNet.DotNetMethod,WithoutHaste.DataFiles.DotNet.DotNetMethod)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.Equals(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.Equals(System.Object)">
            <summary>Equality is based on the full namespace/name/generic-type-parameters of the method, and on parameter-types.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethod.GetHashCode">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetMethod.Category">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetMethod.MethodName">
            <summary>Strongly-typed name.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDelegate.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDelegate.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDelegate.AddAssemblyInfo(System.Type)">
            <summary>Add additional documentation information from the assembly itself.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetIndexer">
            <summary>
            Represents an indexer property.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetProperty">
            <summary>
            Represents a type's property.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetField">
            <summary>
            Represents a type's field.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetField.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetField.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation for Field data.
            </summary>
            <param name="memberElement">Expects tag name "member".</param>
            <example><![CDATA[<member name="F:Namespace.Type.FieldName"></member>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetField.AddAssemblyInfo(System.Reflection.FieldInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetField.PushGenericTypes(System.String[])">
            <summary>
            Update field type with the class's generic-type aliases.
            </summary>
            <param name="genericTypeAliases">Ordered list of aliases.</param>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetField.Category">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetField.AccessModifier">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetField.IsStatic">
            <summary>False means unknown or is not static.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetField.TypeName">
            <summary>Fully qualified name of data type, if known. Null if not known.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetField.FullTypeName">
            <summary>The "FullName" of the field data type.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetField.ConstantValue">
            <summary>For constant fields, the value of the constant. Null otherwise.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetProperty.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetProperty.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation for Property data.
            </summary>
            <param name="memberElement">Expects tag name "member".</param>
            <example><![CDATA[<member name="P:Namespace.Type.PropertyName"></member>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetProperty.AddAssemblyInfo(System.Reflection.PropertyInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetProperty.GetterMethod">
            <summary>The "get" method of the property.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetProperty.SetterMethod">
            <summary>The "set" method of the property.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetProperty.HasGetterMethod">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetProperty.HasSetterMethod">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetIndexer.Parameters">
            <summary>The list of indexer keys.</summary>
            <example>Indexer <c>int this[string key]</c> has one parameter named "key".</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetParameter})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation for Indexer data.
            </summary>
            <param name="memberElement">Expects tag name "member".</param>
            <example><![CDATA[<member name="P:Namespace.Type.Item(System.Int32)"></member>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.AddAssemblyInfo(System.Reflection.PropertyInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.MatchesSignature(System.Reflection.MethodInfo)">
            <summary>
            Returns true if this method's signature matches the reflected MethodInfo.
            </summary>
            <param name="methodInfo">Expects a method with name "get_Item".</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.MatchesArguments(System.Reflection.ParameterInfo[])">
            <summary>
            Returns true if this method's parameter list matches the reflected ParameterInfo.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.Matches(WithoutHaste.DataFiles.DotNet.DotNetCommentQualifiedLinkedGroup)">
            <summary>
            Returns true if this indexer's signature matches the link.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.Matches(WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLinkedGroup)">
            <summary>
            Returns true if this indexer's signature matches the link.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.Matches(WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink)">
            <summary>
            Returns true if this indexer's signature matches the method signature.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.Matches(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary>
            Returns true if this indexer's signature matches the method signature.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetIndexer.PushGenericTypes(System.String[])">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetIndexer.ParameterTypesSignature">
            <summary>Returns indexer parameters formatted as "[TypeA,TypeB]".</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetIndexer.ParametersSignature">
            <summary>Returns indexer parameters formatted as "[TypeA a, TypeB b]".</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetMethodDestructor">
            <summary>
            Represents a method that is a destructor.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodDestructor.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodDestructor.AddAssemblyInfo(System.Reflection.ConstructorInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetPropertyMethod">
            <summary>
            Represents a getter or a setter method of a property.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetPropertyMethod.#ctor">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetPropertyMethod.#ctor(WithoutHaste.DataFiles.DotNet.AccessModifier,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetPropertyMethod.FromAssemblyInfo(System.Reflection.MethodInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetPropertyMethod.IsAbstract">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetPropertyMethod.AccessModifier">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassNameTreeNode">
            <summary>
            A node in a tree data structure made up of DotNetQualifiedClassNames organized by their namespaces.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassNameTreeNode.Generate(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName})">
            <summary>
            Organize a list of namespaces into a tree, based on which namespaces are within other namespaces.
            </summary>
            <returns>
            Returns the root of the new tree.
            If there is one top-level namespace, root.Value will be that namespace.
            If there are more than one top-level namespaces, root.Value will be null and root.Children will contain the top-level namespaces.
            </returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassNameTreeNode.Insert(WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName)">
            <summary>
            Insert a new namespace into its proper position, based on the current node as the root.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassNameTreeNode.Parent">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassNameTreeNode.Value">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassNameTreeNode.Children">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric">
            <summary>
            Represents a generic-type parameter that is in reference to a class's declared generic types.
            </summary>
            <example>
            The "T" and "U" in the constructor parameters.
            <![CDATA[
            class MyGeneric<T,U>
            {
                public MyGeneric(T t, U u) { }
            }
            ]]>
            </example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetReferenceGeneric">
            <summary>
            Represents a generic-type parameter that is not in a class declaration or a method declaration.
            </summary>
            <example>The "U"s in MyMethod(<![CDATA[List<U>]]> list, U obj).</example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName">
            <summary>
            Represents a fully qualified type name, for return types / field types / property types / parameter types.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName">
            <summary>
            Represents a fully qualified type name or member name.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.localName">
            <summary>Name without namespace or declaring type or generic type parameters.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.#ctor(System.String,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.#ctor(System.String,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.#ctor(System.String[])">
            <summary>Builds the qualified name from each segment provided, with the first string being the root namespace and the last string being the local name.</summary>
            <exception cref="T:System.ArgumentException">List of names cannot be empty.</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation type, method, or other member name.
            </summary>
            <param name="name">
              <list>
                <item>Names starting with "T:" are parsed as Type names.</item>
                <item>Names starting with "M:" are parsed as Method names.</item>
                <item>Names starting with "F:" are parsed as Member names.</item>
                <item>Names starting with "P:" are parsed as Member names.</item>
                <item>Names starting with "E:" are parsed as Member names.</item>
                <item>All others are parsed as Member names.</item>
              </list>
            </param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.MemberNameFromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation member name.
            </summary>
            <remarks>
            There is no support for generic types here because .Net XMl documentation does not include member types, just the names.
            </remarks>
            <remarks>
            Does not parse method names; use DotNetQualifiedMethodName.FromVisualStudioXml(string) instead.
            </remarks>
            <example>
            Expected formats:
            - "F:NamespaceA.NamespaceB.MemberC"
            - "P:NamespaceA.NamespaceB.MemberC"
            - "E:NamespaceA.NamespaceB.MemberC"
            - "NamespaceA.NamespaceB.MemberC"
            - "NamespaceA.NamespaceB.InterfaceNamespace#Interface#MemberC"
            </example>
            <param name="name">Name may or may not start with /[FPE]:/</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.FromAssemblyInfo(System.Type)">
            <summary>
            Parses a System.Reflection.AssemblyInfo full name.
            </summary>
            <list>
              <item>The escape character is backslash (\)</item>
              <item>Nested types are separated with '+' instead of '.'</item>
              <item>Class declaration of generic types are shown the same as .Net XML documentation: MyType`1 for one generic type</item>
              <item>When a generic type is defined: System.Collections.Generic.List`1[U], where U is the type alias from the class declaration</item>
            </list>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.FromAssemblyInfo(System.String)">
            <summary>See <see cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.FromAssemblyInfo(System.Type)"/></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.GetFullListOfLocalNames">
            <summary>
            Collect full list of local names used throughout documentation.
            Includes namespaces, internal types, external types, and members.
            Does not include generic paremeters.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Combine(System.String[])">
            <summary>Return the names combined with a '.' delimiter.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Combine(System.Collections.Generic.List{System.String})">
            <summary>Return the names combined with a '.' delimiter.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.IsWithin(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>Returns true if this Name is nested inside the other Name.</summary>
            <example>"System.Text.RegularExpressions" is within "System.Text" and "System".</example>
            <example>"System" is not within null or empty Name.</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.GetLocalized(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns a new name object which has been localized to the provided other name. The current object is not altered.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Localize(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Simplifies this qualified name based on the <paramref name='other'/> name.
            In other words, removes the portion of the namespace that this and the <paramref name='other'/> have in common.
            Alters the current object.
            </summary>
            <remarks>Will always keep at least the LocalName.</remarks>
            <remarks>Preserves explicit interface implementations.</remarks>
            <example>"System.Collections.Generic.List".Localize("System.Collections") returns "Generic.List".</example>
            <example>"System.Collections.Generic.List".Localize("System.Collections.Standard.List") returns "Standard.List".</example>
            <example>"System.Collections.Generic.List".Localize("System.Collections.Generic.List") returns "List".</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Flatten">
            <summary>
            Returns an array of the name segments that make up this qualified name.
            </summary>
            <remarks>Does not include explicit interface implementations.</remarks>
            <example>"System.Collections.Generic".Flatten() returns ["System", "Collections", "Generic"].</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.op_Implicit(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)~System.String">
            <summary>Returns dot notation of namespaces and local name.</summary>
            <example>A.B.C.LocalName</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.ToString">
            <summary>Returns dot notation of namespaces and local name.</summary>
            <example>A.B.C.LocalName</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.ToString(System.Int32)">
            <example>
            For "System.Collections.Generic.List", 
            Depth = 0 at "List"
            Depth = 1 at "Generic"
            Depth = 2 at "Collections"
            Depth = 3 at "System"
            </example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.op_Equality(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Equals(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.op_Inequality(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Equals(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Equals(System.Object)">
            <summary>Names converted to strings must match exactly to be considered equal.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.op_LessThan(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.CompareTo(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.op_GreaterThan(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.CompareTo(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Compare(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.CompareTo(System.Object)"/>
            With protection against either object being null.
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.CompareTo(System.Object)">
            <summary>
            Names are sorted alphabetically, per namespace, starting with the root.
            </summary>
            <remarks>Explicit interface implementations are considered only as a last resort.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.Clone">
            <summary>
            Returns deep clone of qualified name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.ToDotNetQualifiedTypeName">
            <summary>
            Convert a base-type DotNetQualifiedName to a DotNetQualifiedTypeName.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.FullNamespace">
            <summary>Fully qualified namespace.</summary>
            <remarks>Null if there is no namespace.</remarks>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.FullName">
            <summary>Fully qualified name.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.LocalName">
            <summary>Local data type name, written in the c# style.</summary>
            <example><![CDATA[MyType<T> instead of MyType`1]]></example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.LocalXmlName">
            <summary>Local data type name, written in the Xml style.</summary>
            <example><![CDATA[MyType`1 instead of MyType<T>]]></example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName.ExplicitInterface">
            <summary>
            The interface being implemented, if this is a property or method with an explicit interface implementation.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.GenericTypeParameters">
            <summary>If this is a generic type, these are the specified parameter types.</summary>
            <example>In parameter type <![CDATA[List<System.String>]]>, System.String is the generic-type parameter of List.</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.#ctor(System.String,WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.#ctor(System.String,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.#ctor(System.String,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName},WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName)">
            <param name="localName"></param>
            <param name="genericTypeParameters">List of generic-type parameters within this type.</param>
            <param name="fullNamespace"></param>
            <exception cref="T:System.ArgumentException"><paramref name="genericTypeParameters"/> cannot be null.</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation type name.
            Not intended for type declarations. Intended for field types, property types, parameter types, and return types.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.FromAssemblyInfo(System.Type)">
            <summary>
            Parses a System.Reflection.AssemblyInfo full name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.FromAssemblyInfo(System.Type,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName})">
            <summary>
            Parses a System.Reflection.AssemblyInfo full name.
            </summary>
            <list>
              <item>The escape character is backslash (\)</item>
              <item>Nested types are separated with '+' instead of '.'</item>
              <item>Class declaration of generic types are shown the same as .Net XML documentation: MyType`1 for one generic type</item>
              <item>When a generic type is defined: System.Collections.Generic.List`1[U], where U is the type alias from the class declaration</item>
            </list>
            <param name="type"></param>
            <param name="bubbleUpParameters">Optional. When reflection gives type information about a generic type nested inside a generic type, all the generic-type-arguments are listed in the inner-most type. This is for passing that information back up the chain of types.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.FromAssemblyInfo(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.GetFullListOfLocalNames">
            <summary>
            Collect full list of local names used throughout documentation.
            Includes namespaces, internal types, external types, and members.
            Does not include generic paremeters.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.GetLocalized(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.Localize(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <inheritdoc />
            <remarks>
            All generic parameters are also localized.
            </remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.Clone">
            <summary>
            Returns deep clone of qualified name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.FullTypeNamespace">
            <summary>
            Strongly-typed FullNamespace.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName.LocalName">
            <summary>Local data type name with generic type parameters (if applicable).</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetReferenceGeneric.genericTypeIndex">
            <summary>0-based index in class's generic type list corresponding to this parameter.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceGeneric.SetAlias(System.String[])">
            <summary>
            Set the generic-type alias of this type, based on this ordered list of aliases.
            </summary>
            <returns>Returns False if the index is out of bounds and the alias is not updated.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceGeneric.Localize(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Generic type references cannot be localized.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetReferenceGeneric.LocalName">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetReferenceGeneric.Alias">
            <summary>
            The generic-type alias specified in the assembly. Null if not known.
            Whether this refers to a class-generic or method-generic is determined by the subclass.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.#ctor(System.Int32)">
            <summary>
            Creates a generic-type using the <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.DefaultGenericTypeNames"/>.
            </summary>
            <remarks>
            Index value will be set to 0 if it is less than 0.
            Alias will be set to "?" if the index value is out of range.
            </remarks>
            <param name="genericTypeIndex">0-based index of generic-type in relation to the class's declaration.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.#ctor(System.Int32,System.String)">
            <summary>
            Creates a generic-type using the provided alias.
            </summary>
            <remarks>
            Index value will be set to 0 if it is less than 0.
            </remarks>
            <param name="genericTypeIndex">0-based index of generic-type in relation to the class's declaration.</param>
            <param name="alias">The provided value will be used for the type alias, regardless of the index.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation type names that reference class generic types parameters.
            </summary>
            <example>
            Given:
            <![CDATA[
            public class MyType<T>
            { 
            	T MyField;
            }
            ]]> 
            the type of the field is formatted as <c>`0</c>.</example>
            <returns>Returns a default value if the <paramref name='typeName'/> is not in the correct format.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.HasExpectedVisualStudioXmlFormat(System.String)">
            <summary>
            Check if a string is properly formatted as a parameter referencing a class-generic-type.
            </summary>
            <example><c>`0</c>, <c>`1</c>, <c>`2</c>, etc.</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns true if these types match. Does not look at aliases.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.MatchesSignature(System.Type)">
            <summary>
            Returns true if this generic type matches the reflected type.
            Compares generic indexes and whether it is a class-generic or method-generic.
            Does not compare aliases or which specific class/method the type is referencing.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.GetLocalized(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceClassGeneric.Clone">
            <summary>
            Returns deep clone of generic reference name.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentCode">
            <summary>
            Represents an inline section of code in the comments.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentText">
            <summary>
            Represents a plain text segment of comments.
            </summary>
            <remarks>
            Endline characters (\n) are preserved.
            
            A multiline block of text will have leading white-space removed as a block.
            So if each line starts with two tabs, two tabs will be removed from the beginning of each line.
            </remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentText.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentText.ToString">
            <summary>Returns full text.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentText.Text">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentText.IsEmpty">
            <summary>True if text is null or empty string.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCode.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCode.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation c tag.</summary>
            <example><![CDATA[<c>code fragment</c>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCode.FromVisualStudioXml(System.Xml.Linq.XCData)">
            <summary>Parses .Net XML documentation CDATA tag.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentCodeBlock">
            <summary>
            Represents a section of code in the comments.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCodeBlock.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCodeBlock.#ctor(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCodeBlock.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation code tag.</summary>
            <example><![CDATA[<code>code statements</code>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCodeBlock.FromVisualStudioXml(System.Xml.Linq.XCData)">
            <summary>Parses .Net XML documentation CDATA tag.</summary>
            <remarks>Sets language to "xml".</remarks>
            <example><![CDATA[<![CDATA[xml statements\]\]>]]></example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentCodeBlock.Language">
            <summary>Specify the language of the code block. Null if not known.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem">
            <summary>
            Represents a listheader or item in a .Net XML documentation list.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.#ctor">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.#ctor(System.String,System.String,System.Boolean)">
            <summary>Plain text <paramref name='term'/> and <paramref name='description'/>.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentGroup,WithoutHaste.DataFiles.DotNet.DotNetCommentGroup,System.Boolean)">
            <summary><paramref name='term'/> and <paramref name='description'/> containing more than plain text, such as a <c>see</c> tag.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation listheader or item.</summary>
            <example>
            Format options:
            <![CDATA[
              <listheader>
                plain text
              </listheader>
              <listheader>
                <term>Term</term>
              </listheader>
              <listheader>
                <description>Description</description>
              </listheader>
              <listheader>
                <term>Term</term>
                <description>Description</description>
              </listheader>
            ]]>
            </example>
            <example>
            Format options:
            <![CDATA[
              <item>
                plain text
              </item>
              <item>
                <term>Term</term>
              </item>
              <item>
                <description>Description</description>
              </item>
              <item>
                <term>Term</term>
                <description>Description</description>
              </item>
            ]]>
            </example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.IsHeader">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.Term">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentListItem.Description">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentParameter">
            <summary>
            Represents a parameter description in the comments.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink,WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink,WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameter.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation for param.</summary>
            <example><![CDATA[<param name="myParam">nested comments</param>]]></example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentParameter.ParameterLink">
            <summary>Strongly-typed link.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink">
            <summary>
            Represents a link in the comments to an internal parameter name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink.#ctor(System.String,WithoutHaste.DataFiles.DotNet.CommentTag)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation for paramref.</summary>
            <example><![CDATA[<paramref name="paramName" />]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink.ToString">
            <summary>Name</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink.Name">
            <summary>Name of the parameter in local method.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentParameterLink.FullName">
            <inheritdoc />
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentRow">
            <summary>
            Represents a row of data in a .Net XML documentation table.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetCommentRow.Cells">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentRow.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetCommentCell},System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentRow.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation "listheader" or "item", expecting one "term" per cell.</summary>
            <example><![CDATA[<listheader><term>Header 1</term><term>Header 2</term></listheader>]]></example>
            <example><![CDATA[<item><term>Cell 1</term><term>Cell 2</term></item>]]></example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentRow.IsHeader">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentRow.ColumnCount">
            <summary>Number of columns (cells) in the row.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentRow.Item(System.Int32)">
            <summary>
            Returns the selected cell of the row. Returns an empty cell if no cell is found.
            </summary>
            <remarks>Returns an empty cell because Row does not know the number of columns in the Table, just how many cells are filled on this row.</remarks>
            <param name="columnIndex">0-based index of table column.</param>
            <exception cref="T:System.IndexOutOfRangeException">Column index is negative.</exception>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameter">
            <summary>
            Represents a generic-type parameter description in the comments.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink,WithoutHaste.DataFiles.DotNet.DotNetComment)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink,WithoutHaste.DataFiles.DotNet.DotNetComment[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetComment})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameter.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation for typeparam.</summary>
            <example><![CDATA[<typeparam name="T">nested comments</typeparam>]]></example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink">
            <summary>
            Represents a link in the comments to an internal generic-type parameter.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink.#ctor(System.String,WithoutHaste.DataFiles.DotNet.CommentTag)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTypeParameterLink.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation for typeparamref.</summary>
            <example><![CDATA[<typeparamref name="T" />]]></example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetMethodConstructor">
            <summary>
            Represents a method that is a constructor.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodConstructor.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodConstructor.AddAssemblyInfo(System.Reflection.ConstructorInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodConstructor.SetClassName(WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName)">
            <summary>
            Constructors need to reference the actual name of their type so they display the right name with aliases.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator">
            <summary>
            Represents a method that is an operator.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.OperatorOrder">
            <summary>Operators will be sorted into this order.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.op_LessThan(WithoutHaste.DataFiles.DotNet.DotNetMethodOperator,WithoutHaste.DataFiles.DotNet.DotNetMethodOperator)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.CompareTo(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.op_GreaterThan(WithoutHaste.DataFiles.DotNet.DotNetMethodOperator,WithoutHaste.DataFiles.DotNet.DotNetMethodOperator)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.CompareTo(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.CompareTo(System.Object)">
            <summary>
            Methods are sorted:
            <list type="number">
            	<item>alphabetically by namespace</item>
            	<item>then into <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetMethodOperator.OperatorOrder"/></item>
            	<item>then as a normal method (see <see cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.CompareTo(System.Object)"/></item>
            </list>
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName">
            <summary>
            Represents a fully qualified method name.
            </summary>
            <remarks>
            Cannot handle methods that declare more than 12 generic types,
            such as <![CDATA[MyMethod<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13>]]>.
            </remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.DefaultGenericTypeNames">
            <summary>Default names that will be given to generic-method-types, in order.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.genericTypeAliases">
            <summary>Specific generic type aliases for this method. Defaults to the <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.DefaultGenericTypeNames"/> values.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.Parameters">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.#ctor(System.String,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetParameter},WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName,System.Int32,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.#ctor(System.String,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetParameter},WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName,System.Int32,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation method signature.
            </summary>
            <example>
              <para>
              XML documentation of generic types: Backtics are followed by integers, identifying generic types.
              </para>
              <para>
              Double backtics (such as ``1) on a method name indicate a count of generic types for the method.
              For example, <![CDATA[MyMethod<A,B,C>]]> is documented as <c>MyMethod``3</c>.
              </para>
              <para>
              Anywhere else within this method's documentation that a double backtic appears, it indicates the index of the generic type in reference to the method declaration.
              For example, <![CDATA[MyMethod<A,B,C>(A,B,C)]]> is documented as <c>MyMethod``3(``0,``1,``2)</c>.
              </para>
              <para>
              A method that uses both its own generic types AND generic types from the class declaration will look like this:
              For example, <![CDATA[MyMethod<A,B,C>(A,B,C,T,U)]]> is documented as <c>MyMethod``3(``0,``1,``2,`0,`1)</c>.
              </para>
            </example>
            <example>
              <para>
              XML documentation of implicit and explicit operators:
              </para>
              <para>
              <c>static explicit operator int(MyClass a)</c> becomes <c>MyClass.op_Explicit(MyClass)~System.Int32</c>.
              </para>
              <para>
              <c>static implicit operator int(MyClass a)</c> becomes <c>MyClass.op_Implicit(MyClass)~System.Int32</c>.
              </para>
            </example>
            <param name="signature">Name may or may not start with "M:". Includes parameter list.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.ParametersFromVisualStudioXml(System.String)">
            <summary>
            Parse .Net XML documentation parameter lists.
            </summary>
            <param name="text">
            Expects: null, or empty string, or "(type, type, type)"
            </param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesSignature(System.Reflection.MethodInfo)">
            <summary>
            Returns true if this method's signature matches the reflected MethodInfo.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary>
            Returns true if this method's signature matches the other method signature.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesLocalSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary>
            Returns true if this method's signature matches the other method signature.
            Looks at local name instead of entire namespace.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesArguments(System.Reflection.ParameterInfo[])">
            <summary>
            Returns true if this method's parameter list matches the reflected ParameterInfo. Checks parameter types, not names.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.MatchesArguments(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetParameter})">
            <summary>
            Returns true if this method's parameter list matches the provided parameter list. Checks parameter types, not names.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.AddAssemblyInfo(System.Reflection.MethodInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.SetLocalName(System.String)">
            <summary>Set the local name of the method. Does not affect generic type parameters or method parameters.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.PushMethodGenericTypes(System.String[])">
            <summary>
            Update method parameter types and return type with the method's generic-type aliases.
            </summary>
            <param name="methodGenericTypeAliases">Ordered list of aliases.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.PushClassGenericTypes(System.String[])">
            <summary>
            Update method parameter types and return type with the class's generic-type aliases.
            </summary>
            <param name="classGenericTypeAliases">Ordered list of aliases.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.SetClassName(WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName)">
            <summary>
            Constructors need to reference the actual name of their type so they display the right name with aliases.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.op_LessThan(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.CompareTo(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.op_GreaterThan(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName,WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.CompareTo(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.CompareTo(System.Object)">
            <summary>
            Methods are sorted:
            <list type='number'>
            	<item>alphabetically by namespace</item>
            	<item>alphabetically by explicit interface implementation</item>
            	<item>then parameter list, shortest to longest</item>
            	<item>then alphabetically by parameter types</item>
            	<item>then alphabetically by return type (for some operators)</item>
            </list>
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.Clone">
            <summary>
            Returns deep clone of qualified name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.FullClassNamespace">
            <summary>
            Strongly-typed FullNamespace.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.LocalName">
            <summary>Local method name with generic type parameters (if applicable).</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.LocalXmlName">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.ParametersWithNames">
            <summary>Returns parameter list formatted as: (TypeA a, TypeB b)</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.ParametersWithoutNames">
            <summary>Returns parameter list formatted as: (TypeA, TypeB)</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.IsGeneric">
            <summary>True for generic methods.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.GenericTypeCount">
            <summary>The number of generic-types required by the method declaration.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.ReturnTypeName">
            <summary>Fully qualified name of return data type, if known. Null if not known.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.ReturnTypeIsPartOfSignature">
            <summary>
            True if the return type is necessary for distinguishing this method name from others.
            </summary>
            <example>True for implicit and explicit conversion operators.</example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName">
            <summary>
            Represents a fully qualified class name, for class declarations.
            </summary>
            <remarks>
            Cannot handle classes that declare more than 12 generic types,
            such as <![CDATA[MyType<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13>]]>.
            </remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.DefaultGenericTypeNames">
            <summary>Default names that will be given to generic-types, in order.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.genericTypeAliases">
            <summary>Specific generic type aliases for this method. Defaults to the <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.DefaultGenericTypeNames"/> values.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.#ctor">
            <summary>Empty constructor</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.#ctor(System.String,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.#ctor(System.String,WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation type name or namespace name.
            </summary>
            <remarks>
            Does not differentiate between types and namespaces 
            because a nested type will have other type names in its namespace path
            and there are no important diffences in parsing the two.
            </remarks>
            <example>
              <para>
                How .Net xml documentation formats generic types:
                Backtics are followed by integers, identifying generic types.
              </para>
              <para>
                Single backtics (such as `1) on a class declaration indicate a count of generic types for the class.
                For example, <![CDATA[MyGenericType<T,U,V>]]> is documented as <c>MyGenericType`3</c>.
                Anywhere else within this object's documentation that a single backtic appears, it indicates the zero-based index of the generic type in reference to the class declaration.
                For example, the constructor <![CDATA[MyGenericType(T,U,V)]]> is documented as <c>MyGenericType.#ctor(`0,`1,`2)</c>.
              </para>
            </example>
            <param name="name">Name may or may not start with "T:"</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.AddAssemblyInfo(System.Type)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.Clone">
            <summary>
            Returns deep clone of qualified name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.FullClassNamespace">
            <summary>
            Strongly-typed FullNamespace.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.LocalName">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.LocalXmlName">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.IsGeneric">
            <summary>
            True if this is a generic class name.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.GenericTypeCount">
            <summary>The number of generic-types required by the class declaration.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName.GenericTypeAliases">
            <summary>
            A copy of the ordered list of generic-type aliases used by this class name.
            </summary>
            <remarks>Non-generic class names may still have default alias values.</remarks>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric">
            <summary>
            Represents a generic-type parameter that is in reference to a method's declared generic types.
            </summary>
            <example>
            The "A" and "B" in the MyMethod parameters.
            <![CDATA[
            class MyGeneric<T,U>
            {
                public MyGeneric(T t, U u) { }
                
                public void MyMethod<A,B>(A a, B b, T t, U u) { }
            }
            ]]>
            </example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.#ctor(System.Int32)">
            <summary>
            Creates a generic-type using the <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName.DefaultGenericTypeNames"/>.
            </summary>
            <remarks>
            Index value will be set to 0 if it is less than 0.
            Alias will be set to "?" if the index value is out of range.
            </remarks>
            <param name="genericTypeIndex">0-based index of generic-type in relation to the method's declaration.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.#ctor(System.Int32,System.String)">
            <summary>
            Creates a generic-type using the provided alias.
            </summary>
            <remarks>
            Index value will be set to 0 if it is less than 0.
            </remarks>
            <param name="genericTypeIndex">0-based index of generic-type in relation to the method's declaration.</param>
            <param name="alias">The provided value will be used for the type alias, regardless of the index.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation type names that reference method generic type parameters.
            </summary>
            <example>
            Given:
            <![CDATA[
            public class MyType
            { 
            	public void MyMethod<A>(A a) { }
            }
            ]]> 
            the type of the method parameter is formatted as <c>``0</c>.</example>
            <returns>Returns a default value if the <paramref name='typeName'/> is not in the correct format.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.HasExpectedVisualStudioXmlFormat(System.String)">
            <summary>
            Check if a string is properly formatted as a parameter referencing a method-generic-type.
            </summary>
            <example><c>``0</c>, <c>``1</c>, <c>``2</c>, etc.</example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns true if these types match. Does not look at aliases.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.MatchesSignature(System.Type)">
            <summary>
            Returns true if this generic type matches the reflected type.
            Compares generic indexes and whether it is a class-generic or method-generic.
            Does not compare aliases or which specific class/method the type is referencing.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.GetLocalized(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetReferenceMethodGeneric.Clone">
            <summary>
            Returns deep clone of generic reference name.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetSettings">
            <summary>
            Global settings for the entire DotNet namespace.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetSettings.QualifiedNameConverter">
            <summary>
            When DotNetQualifiedNames are converted to strings, this converter will be automatically applied to each:
            * generic type parameter
            * method parameter
            * type name
            
            Set to null to not use any converter.
            </summary>
            <remarks>
            Setting always defaults to <see cref="M:WithoutHaste.DataFiles.DotNet.DotNetSettings.DefaultQualifiedNameConverter(System.String,System.Int32)"/>.
            With target frameworks less than 3.5, you can turn this on or off with <see cref="!:UseDefaultQualifiedNameConverter(bool)"/>.
            With target frameworks 3.5 or higher, you can set this to a custom function.
            
            See <see cref="M:WithoutHaste.DataFiles.DotNet.DotNetSettings.DefaultQualifiedNameConverter(System.String,System.Int32)"/> for usage examples.
            </remarks>
            <example>
            <code>
            	DotNetSettings.QualifiedNameConverter = DotNetSettings.DefaultQualifiedNameConverter;
            	string displayString = myQualifiedTypeName.FullName;
            </code>	
            </example>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetSettings.AdditionalQualifiedNameConverter">
            <summary>
            A second level <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetSettings.QualifiedNameConverter"/> to provide further processing.
            This method will be run after <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetSettings.QualifiedNameConverter"/> for each <see cref="T:WithoutHaste.DataFiles.DotNet.DotNetQualifiedName"/>.
            
            Set to null to not use any converter.
            </summary>
            <remarks>
            Setting always defaults to null.
            With target frameworks 3.5 or higher, you can change this setting.
            </remarks>
            <example>
            <code>
            	DotNetSettings.QualifiedNameConverter = DotNetSettings.DefaultQualifiedNameConverter;
            	DotNetSettings.AdditionalQualifiedNameConverter = myCustomConverter;
            	string displayString = myQualifiedTypeName.FullName;
            </code>	
            </example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetSettings.DefaultQualifiedNameConverter(System.String,System.Int32)">
            <summary>
            Converts all standard .Net types to their common aliases.
            </summary>
            <example>
            <code>
            	DotNetSettings.QualifiedNameConverter = DotNetSettings.DefaultQualifiedNameConverter;
            	string displayString = myQualifiedTypeName.FullName;
            </code>
            </example>
            <example>
            <![CDATA[
            "System.Int32" => "int"
            "System.Collections.Generic.List<System.Int32> => "System.Collections.Generic.List<int>"
            "MyType.MyMethod(System.Int32)" => "MyType.MyMethod(int)"
            ]]>
            </example>
            <param name="fullName">
            When processing name "System.Collections.Generic.List", fullName will be "System" then "System.Collections" then "System.Collections.Generic" then "System.Collections.Generic.List".
            </param>
            <param name="depth">
            When processing name "System.Collections.Generic.List", depth will be 3 at "System", then 2 at "Collections", then 1 at "Generic", then 0 at "List".
            </param>
        </member>
        <member name="T:WithoutHaste.DataFiles.LoadException">
            <summary>Error loading a file.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.LoadException.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.StringFormatException">
            <summary>Badly formatted string.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.StringFormatException.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.XmlFormatException">
            <summary>
            Badly formatted xml, or unexpected xml.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.XmlFormatException.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.IMarkdownInLine">
            <summary>
            Represents a markdown element that can be included within a MarkdownLine (i.e. within text).
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.IMarkdownInSection">
            <summary>
            Represents a markdown element that can be included within a MarkdownSection.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.IMarkdownInSection.ToMarkdownString(System.String)">
            <summary>
            Return markdown-formatted text.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.IMarkdownInList">
            <summary>
            Represents a markdown element that can be added to a MarkdownList.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.IMarkdownIsBlock">
            <summary>
            Represents a Markdown element that ends with a double endline.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownCode">
            <summary>
            Represents inline code or CDATA.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownCode.Text">
            <summary>
            Full text of code.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownCode.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownCode.ToMarkdownString(System.String)">
            <inheritdoc />
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownCode.GetLongestBacktics">
            <summary>
            Returns the longest substring in the code that is all backtics (`).
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownCodeBlock">
            <summary>
            Represents a code block or CDATA block.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownCodeBlock.Text">
            <summary>
            Full text of code, with endline characters between lines.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownCodeBlock.Language">
            <summary>
            Language tag supported by highlight.js for syntax highlighting.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownCodeBlock.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownCodeBlock.#ctor(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownCodeBlock.ToMarkdownString(System.String)">
            <inheritdoc />
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownFile">
            <summary>
            Represents a markdown file.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownFile.Extensions">
            <summary>Accepted markdown file extensions.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownFile.#ctor">
            <summary>
            Create an empty markdown file.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownFile.AddSection(System.String)">
            <summary>
            Creates new section and adds it to the end of the file. Defaults to depth 1.
            </summary>
            <param name="header">Section header</param>
            <returns>The new section</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownFile.AddSection(WithoutHaste.DataFiles.Markdown.MarkdownSection)">
            <summary>
            Adds existing section to the end of this file. Depths are not updated.
            </summary>
            <param name="section">Existing section.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownFile.ToMarkdownString">
            <summary>
            Returns full markdown text for file, formatted for legibility.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownInlineLink">
            <summary>
            Represents markdown inline-style link.
            </summary>
            <example>
            <c>new MarkdownInlineLink("google", "www.google.com")</c> is converted to string <c>[google](www.google.com)</c>.
            </example>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownLink">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownLink.text">
            <summary>Styled text of link.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLink.#ctor(System.String)">
            <summary>Link text and url are the same.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLink.#ctor(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLink.#ctor(WithoutHaste.DataFiles.Markdown.MarkdownText,System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLink.ToMarkdownString(System.String)">
            <summary>
            Outputs markdown-formatted text.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownLink.Text">
            <summary>Plain text of link.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownLink.Url">
            <summary>Url of target.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownInlineLink.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownInlineLink.#ctor(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownInlineLink.#ctor(WithoutHaste.DataFiles.Markdown.MarkdownText,System.String)">
            <summary>Accepts formatted text.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownInlineLink.ToMarkdownString(System.String)">
            <inheritdoc />
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownLine">
            <summary>
            Represents one line of text that will end in a line break.
            </summary>
            <remarks>Do not include the trailing white space or endline character.</remarks>
            <example>Displays as: The quick brown fox.  \\n</example>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownLine.elements">
            <summary>
            Ordered inline elements that make up this line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.#ctor(WithoutHaste.DataFiles.Markdown.IMarkdownInLine[])">
            <summary>
            Initialize line with any number of elements.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInLine})">
            <summary>
            Initialize line with any number of elements.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.#ctor(System.String)">
            <summary>
            Initialize line with one MarkdownText element.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Add(System.String)">
            <summary>
            Add a new MarkdownText containing the text to the end of the line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInLine)">
            <summary>
            Add an element to the end of the line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Add(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInLine})">
            <summary>
            Add elements to the end of the line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInLine[])">
            <summary>
            Add elements to the end of the line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Concat(WithoutHaste.DataFiles.Markdown.MarkdownLine)">
            <summary>
            Appends the contents of the second line to end of this line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Prepend(System.String)">
            <summary>
            Add a new MarkdownText containing the text to the beginning of the line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.Prepend(WithoutHaste.DataFiles.Markdown.IMarkdownInLine)">
            <summary>
            Add an element to the beginning of the line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownLine.ToMarkdownString(System.String)">
            <inheritdoc />
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownLine.Elements">
            <summary>
            Ordered inline elements that make up this line.
            </summary>
            <remarks>Expect mostly one plain text element.</remarks>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownLine.IsEmpty">
            <summary>
            True when there are no elements in the line.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownList">
            <summary>
            Represents a markdown list.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownList.#ctor(System.Boolean)">
            <summary>
            Creates an empty list.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownList.#ctor(System.Boolean,WithoutHaste.DataFiles.Markdown.IMarkdownInList[])">
            <summary>
            Creates a list of the specified <paramref name='elements'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownList.#ctor(System.Boolean,WithoutHaste.DataFiles.Markdown.IMarkdownInLine[])">
            <summary>
            Creates a list of MarkdownLines, each containing one of the <paramref name='inLineElements'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownList.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInList)">
            <summary>
            Adds <paramref name='element'/> to the end of the list.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownList.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInLine)">
            <summary>
            Adds new MarkdownLine containing the <paramref name='element'/> to the end of the list.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownList.ToMarkdownString(System.String)">
            <inheritdoc />
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownList.Depth">
            <summary>
            0-indexed nesting depth of list.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownList.IsNumbered">
            <summary>
            True means the list will be numbered. 
            False means the list will be bulleted.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownList.Length">
            <summary>
            The length of the list. Nested lists count as 1 each.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownList.Item(System.Int32)">
            <summary>
            Get an element from the list by 0-based index.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownParagraph">
            <summary>
            Represents a grouping of elements that will end in a single double-line-break.
            </summary>
            <remarks>Nesting paragraphs inside paragraphs will still result in just one double-line-break at the end.</remarks>
            <example>Displays as: The quick brown fox.\\n\\n</example>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.elements">
            <summary>
            Ordered inline elements that make up this line.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.#ctor(WithoutHaste.DataFiles.Markdown.IMarkdownInSection[])">
            <summary>
            Initialize paragraph with any number of elements.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInSection})">
            <summary>
            Initialize paragraph with any number of elements.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.#ctor(System.String)">
            <summary>
            Initialize paragraph with one MarkdownText element.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Add(System.String)">
            <summary>
            Add a new MarkdownText containing the text to the end of the paragraph.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInSection)">
            <summary>
            Add an element to the end of the paragraph.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Add(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInSection})">
            <summary>
            Add elements to the end of the paragraph.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInSection[])">
            <summary>
            Add elements to the end of the paragraph.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Prepend(System.String)">
            <summary>
            Add a new MarkdownText containing the text to the beginning of the paragraph.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Prepend(WithoutHaste.DataFiles.Markdown.IMarkdownInSection)">
            <summary>
            Add an element to the beginning of the paragraph.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.ToMarkdownString(System.String)">
            <summary>
            Convert the paragraph to markdown-formatted text.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.Elements">
            <summary>
            Ordered elements that make up this paragraph.
            </summary>
            <remarks>Expect mostly one plain text element.</remarks>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownParagraph.IsEmpty">
            <summary>
            True when there are no elements in the line.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownSection">
            <summary>
            Represents a header and all contents until the next header of the same depth.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.#ctor(System.String,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddSection(System.String)">
            <summary>
            Creates new section and adds it to the end of this section. Defaults to depth of parent + 1.
            </summary>
            <param name="header">Section header</param>
            <returns>The new section</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddSection(WithoutHaste.DataFiles.Markdown.MarkdownSection)">
            <summary>
            Adds existing section to the end of this section. Depths are updated.
            </summary>
            <param name="section">Existing section.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInSection)">
            <summary>
            Adds the element to the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.Add(WithoutHaste.DataFiles.Markdown.IMarkdownInSection[])">
            <summary>
            Adds all the elements to the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.Add(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInSection})">
            <summary>
            Adds all the elements to the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInLine(WithoutHaste.DataFiles.Markdown.IMarkdownInLine)">
            <summary>
            Adds the element in a new MarkdownLine at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInLine(System.String)">
            <summary>
            Adds the text in a new MarkdownLine at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInLine(WithoutHaste.DataFiles.Markdown.IMarkdownInLine[])">
            <summary>
            Adds the elements in a new MarkdownLine at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInLine(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInLine})">
            <summary>
            Adds the elements in a new MarkdownLine at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInParagraph(WithoutHaste.DataFiles.Markdown.IMarkdownInSection)">
            <summary>
            Adds the element in a new MarkdownParagraph at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInParagraph(WithoutHaste.DataFiles.Markdown.IMarkdownInSection[])">
            <summary>
            Adds the elements in a new MarkdownParagraph at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInParagraph(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.IMarkdownInSection})">
            <summary>
            Adds the elements in a new MarkdownParagraph at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.AddInParagraph(System.String)">
            <summary>
            Adds the text in a new MarkdownParagraph at the end of this section.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.EndsWith(System.Type)">
            <summary>
            Returns true if the last element in the section has the specified type.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.ToMarkdownString">
            <duplicate cref="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.ToMarkdownString(System.String)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownSection.ToMarkdownString(System.String)">
            <summary>
            Return markdown-formatted text, taking the previous text of the file into account.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownSection.Depth">
            <summary>
            0-indexed nesting depth of section.
            </summary>
            <example><c># Header</c> is depth 1</example>
            <example><c>## Header</c> is depth 2</example>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownSection.Header">
            <summary>
            Displayed header text.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownSection.IsEmpty">
            <summary>
            True if the section contains no elements.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownSection.Elements">
            <summary>All markdown elements within section.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownTable">
            <summary>
            Represents a markdown table.
            </summary>
            <remarks>
            Markdown requires each table to have exactly 1 header row, so the first row is assumed to be the header.
            </remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownTable.MINIMUM_COLUMN_WIDTH">
            <summary>Minimum column width is 3 to allow for minimum "---" contents indicating header/data divider.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownTable.Rows">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTable.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.Markdown.MarkdownTableRow})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTable.#ctor(WithoutHaste.DataFiles.Markdown.MarkdownTableRow[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTable.Add(WithoutHaste.DataFiles.Markdown.MarkdownTableRow)">
            <summary>Add a row to the end of the table.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTable.ToMarkdownString(System.String)">
            <summary>
            Return markdown-formatted text.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTable.GetColumnWidths">
            <summary>
            Returns the width of the widest cell in each column.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownTableRow">
            <summary>
            Represents one row in a Markdown table.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.MarkdownTableRow.Cells">
            <summary>List of the cells in the row.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTableRow.#ctor">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTableRow.#ctor(System.Collections.Generic.List{System.String})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTableRow.#ctor(System.String[])">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTableRow.Add(System.String)">
            <summary>Add a cell to the end of the row.</summary>
            <param name="cell">Contents of cell.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownTableRow.ToMarkdownString(System.Collections.Generic.List{System.Int32})">
            <summary>
            Return markdown-formatted text.
            </summary>
            <remarks>Column widths are padded an additional 1 space on left and right, per Markdown formatting.</remarks>
            <remarks>Line feed, new line, and tab characters are removed.</remarks>
            <exception cref="T:System.ArgumentException">ColumnWidths cannot be null or shorter than the row.</exception>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.TextStyle">
            <summary>
            Display style of text.
            </summary>
            <remarks>
            Number enum values with powers of 2 to allow bitwise operations.
            </remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.TextStyle.Normal">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.TextStyle.Bold">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.Markdown.TextStyle.Italic">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.Markdown.MarkdownText">
            <summary>
            Represents plain text.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.#ctor(System.String,WithoutHaste.DataFiles.Markdown.TextStyle)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.Bold(System.String)">
            <summary>Generate bold text.</summary>
            <remarks><paramref name="text"/> is trimmed to conform to Markdown formatting requirements.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.Italic(System.String)">
            <summary>Generate italic text.</summary>
            <remarks><paramref name="text"/> is trimmed to conform to Markdown formatting requirements.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.BoldItalic(System.String)">
            <summary>Generate bold-italic text.</summary>
            <remarks><paramref name="text"/> is trimmed to conform to Markdown formatting requirements.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.ToMarkdownString(System.String)">
            <inheritdoc />
            <remarks>Uses ** for bold and _ for italics.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.MarkdownText.EscapeControlCharacters(System.String)">
            <summary>
            Replaces Markdown control characters with HTML encoded equivalents.
            </summary>
            <remarks>
            Handles backtic (`), open angle brace (<![CDATA[<]]>), and close angle brace (<![CDATA[>]]>).
            </remarks>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownText.Text">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.Markdown.MarkdownText.Style">
            <summary></summary>
            <remarks>Supports multiple selections such as <c>TextStype.Bold | TextStyle.Italic</c>.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.Markdown.Utilities.EnsureTwoEndlines(System.String)">
            <summary>
            Ensure that string is null or ends with two end line characters.
            Does not add unneccessary characters.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.CommentTag">
            <summary>
            The type of xml tag that the comment came from.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Unknown">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.C">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Code">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Duplicate">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Example">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Exception">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.InheritDoc">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.List">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Para">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Param">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.ParamRef">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Permission">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Remarks">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Returns">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.See">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.SeeAlso">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Summary">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.TypeParam">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.TypeParamRef">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.CommentTag.Value">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentCell">
            <summary>
            Represents a cell in a table in .Net XML documentation.
            </summary>
            <remarks>
            Does not inherit from DotNetCommentText because a cell cannot appear everywhere text can.
            </remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetCommentCell.EmptyCell">
            <summary>Default empty cell.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCell.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentCell.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation term tag.</summary>
            <example><![CDATA[<term>plain text</term>]]></example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentCell.Text">
            <summary>Cell contents.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentList">
            <summary>
            Represents a list in the comments.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetCommentList.Items">
            <summary>Items in the list.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentList.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetCommentListItem},System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentList.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation list (which may actually be a table).</summary>
            <example>
            <![CDATA[
             <list type="bullet"> <!-- type can also be "number" -->
              <listheader>
               <term>Term</term>
               <description>Description</description>
              </listheader>
              <item>
               <term>Term</term>
               <description>Description</description>
              </item>
             </list>
            ]]>
            </example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentList.IsNumbered">
            <summary>
            True for numbered lists.
            False for bulleted lists.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentList.Item(System.Int32)">
            <summary>Access list items by 0-based index.</summary>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentList.Length">
            <summary>Number of items in the list. Includes headers.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink">
            <summary>
            Represents a link in the comments to an internal or extenal method.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink.FromVisualStudioXml(System.String)">
            <summary>Parses .Net XML documentation cref for methods.</summary>
            <example><![CDATA[<permission cref="Namespace.Type.Method(Type1, Type2)">nested comments and/or plain text</permission>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetMethod)">
            <summary>
            Returns true if this method link and the method have matching signatures, based on the fully qualified name and the list of parameter types.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink.MethodName">
            <summary>Strongly typed name.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentMethodLink.FullSignature">
            <summary>Fully qualified method name with parameters.</summary>
            <example>Namespace.Type.Method()</example>
            <example>Namespace.Type.Method(int,string)</example>
            <example><![CDATA[Namespace.Type.Method(System.Collections.Generic.List<int>)]]></example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetCommentTable">
            <summary>
            Represents a table in the comments.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.Rows">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.#ctor(System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetCommentRow})">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>Parses .Net XML documentation table.</summary>
            <example>
            <![CDATA[
             <list type="table">
              <listheader>
               <term>Column 1</term>
               <term>Column 2</term>
               <term>Column 3</term>
              </listheader>
              <item>
               <term>Row 1, Cell 1</term>
               <term>Row 1, Cell 2</term>
               <term>Row 1, Cell 3</term>
              </item>
             </list>
            ]]>
            </example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.RowCount">
            <summary>Number of rows in the table. Includes header rows and data rows.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.HeaderRowCount">
            <summary>Number of header rows in the table.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.DataRowCount">
            <summary>Number of data (non-header) rows in the table.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.ColumnCount">
            <summary>Maximum number of columns in the table.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetCommentTable.Item(System.Int32,System.Int32)">
            <summary>
            Returns the selected <see cref="T:WithoutHaste.DataFiles.DotNet.DotNetCommentCell"/> of the table. Will return a <see cref="F:WithoutHaste.DataFiles.DotNet.DotNetCommentCell.EmptyCell"/> if the cell is within range but does not actually exist.
            </summary>
            <param name="rowIndex">0-based index of table row.</param>
            <param name="columnIndex">0-based index of table column.</param>
            <exception cref="T:System.IndexOutOfRangeException">Either the row or column index is out of range.</exception>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetEvent">
            <summary>
            Represents a type's event.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetEvent.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetEvent.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation for Event data.
            </summary>
            <param name="memberElement">Expects tag name "member".</param>
            <example><![CDATA[<member name="E:Namespace.Type.EventName"></member>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetEvent.AddAssemblyInfo(System.Reflection.EventInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.FieldCategory">
            <summary>Categories of fields, properties, indexers, and events.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.FieldCategory.Unknown">
            <summary>Not enough information is available to determine field category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.FieldCategory.Normal">
            <summary>No special category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.FieldCategory.Constant">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.FieldCategory.ReadOnly">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.FieldCategory.Abstract">
            <remarks>Value only valid on properties and events.</remarks>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.MethodCategory">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Unknown">
            <summary>Not enough information is available to determine method category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Normal">
            <summary>No special category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Static">
            <summary>Static method.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Extension">
            <summary>Static extension method.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Protected">
            <summary>Protected method.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Abstract">
            <summary>Abstract method.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Virtual">
            <summary>Virtual method.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.MethodCategory.Delegate">
            <summary>Delegate type.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.ParameterCategory">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.Unknown">
            <summary>Insufficient information to determine parameter category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.Normal">
            <summary>Normal parameter.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.OutOrRef">
            <summary>Parameter is either an out or a ref parameter.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.Out">
            <summary>An out parameter.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.Ref">
            <summary>A ref parameter.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.Optional">
            <summary>Parameter has a default value.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.ParameterCategory.Extension">
            <summary>The first parameter in an extension method, i.e. the type being extended.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetParameter">
            <summary>
            Represents a parameter in a method signature.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.#ctor">
            <summary>Empty constructor.</summary>
            <remarks>Category defaults to Unknown.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName)">
            <remarks>Category defaults to Normal.</remarks>
            <param name="typeName">Fully qualified data type name.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedTypeName,WithoutHaste.DataFiles.DotNet.ParameterCategory)">
            <param name="typeName">Fully qualified data type name.</param>
            <param name="category">Category of parameter.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.FromVisualStudioXml(System.String)">
            <summary>
            Parses a .Net XML documentation parameter type name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.AddAssemblyInfo(System.Reflection.ParameterInfo)">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.SetIsExtension">
            <summary>
            Set that this parameter is the first parameter in an extension method.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.PushClassGenericTypes(System.String[])">
            <summary>
            Update method/indexer parameters with the class's generic-type aliases.
            </summary>
            <param name="classGenericTypeAliases">Ordered list of aliases.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.PushMethodGenericTypes(System.String[])">
            <summary>
            Update method parameters with the method's generic-type aliases.
            </summary>
            <param name="methodGenericTypeAliases">Ordered list of aliases.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.MatchesSignature(WithoutHaste.DataFiles.DotNet.DotNetParameter)">
            <summary>
            Returns true if signatures match. Looks at types only, not at names.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.MatchesSignature(System.Reflection.ParameterInfo)">
            <summary>
            Returns true if signatures match. Looks at types only, not at names.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.ToString">
            <duplicate cref="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.SignatureWithName"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.op_Equality(WithoutHaste.DataFiles.DotNet.DotNetParameter,WithoutHaste.DataFiles.DotNet.DotNetParameter)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.Equals(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.op_Inequality(WithoutHaste.DataFiles.DotNet.DotNetParameter,WithoutHaste.DataFiles.DotNet.DotNetParameter)">
            <duplicate cref="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.Equals(System.Object)"/>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.Equals(System.Object)">
            <summary>For equality, parameter type and category must be equal. Parameter name and default value are irrelevant.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetParameter.Clone">
            <summary>
            Returns deep clone of parameter.
            </summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.TypeName">
            <summary>Fully qualified data type name object.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.FullTypeName">
            <summary>Fully qualified data type name.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.LocalTypeName">
            <summary>Local data type name.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.Name">
            <summary>Name of parameter. Null if not known.</summary>
            <example>In <c>MethodName(int a, string b)</c>, the first parameter name is <c>a</c>.</example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.Category">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.DefaultValue">
            <summary>For optional parameters, the default value of the parameter. Null otherwise.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.SignatureWithName">
            <summary>
            Returns formatted parameter with name.
            </summary>
            <example>MyType myName</example>
            <example>out MyType myName</example>
            <example>ref MyType myName</example>
            <example>this MyType myName</example>
            <example>MyType myName = defaultValue</example>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetParameter.SignatureWithoutName">
            <summary>
            Returns formatted parameter without the name.
            </summary>
            <example>MyType</example>
            <example>out MyType</example>
            <example>ref MyType</example>
            <example>this MyType</example>
            <example>MyType = defaultValue</example>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.AccessModifier">
            <summary>Privacy/access modifiers.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.AccessModifier.Unknown">
            <summary>Not enough information is available to determine access modifier.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.AccessModifier.Public">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.AccessModifier.Protected">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.AccessModifier.Internal">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.AccessModifier.InternalProtected">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.AccessModifier.Private">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.TypeCategory">
            <summary>Categories of data types for classes, interfaces, structs, and enums.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Unknown">
            <summary>Not enough information is available to determine type category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Normal">
            <summary>No special category.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Abstract">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Static">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Interface">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Struct">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Enum">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.TypeCategory.Exception">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetType">
            <summary>
            Represents a data type: a class, interface, struct, or enum.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.ImplementedInterfaces">
            <summary>Interfaces this type implements, if known.</summary>
            <remarks>If an interface extends another interface, reflection reports that the type implements both interfaces.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.NestedTypes">
            <summary>Data types defined/nested within this type.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.Delegates">
            <summary>Delegates defined within this type.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.Methods">
            <summary>All methods defined within this type.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.Fields">
            <summary>All fields defined within this type.</summary>
            <remarks>By the .Net definition of "field", meaning that properties and events are not included.</remarks>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.Properties">
            <summary>All properties defined within the type.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetType.Events">
            <summary>All events defined within the type.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.#ctor(WithoutHaste.DataFiles.DotNet.DotNetQualifiedClassName)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FromVisualStudioXml(System.Xml.Linq.XElement)">
            <summary>
            Parse .Net XML documentation for Type data.
            </summary>
            <param name="memberElement">Expects tag name "member".</param>
            <example><![CDATA[<member name="T:Namespace.Type"></member>]]></example>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.Is(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns true if this member's name matches the provided name.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.Owns(WithoutHaste.DataFiles.DotNet.DotNetMember)">
            <summary>
            Returns true if this member is defined within this type or any of its nested type descendents.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.Owns(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns true if this qualified name is defined within this type or any of its nested type dscendents.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.IsDirectChild(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns true if this qualified name is defined directly within this type.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.GetDirectChild(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns the selected field/property/event/method/delegate/type from this type.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FindType(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns the selected type, whether it is the current type or one of its nested type descendents. Returns null if the type is not found.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FindInheritedField(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetType},System.String)">
            <summary>
            Returns the selected field, if it exists in this type.
            </summary>
            <param name="FindType">Function that returns the selected type from all known types in the assembly.</param>
            <param name="localName">Name of field, local to this type.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FindInheritedProperty(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetType},System.String)">
            <summary>
            Returns the selected property, if it exists in this type.
            </summary>
            <param name="FindType">Function that returns the selected type from all known types in the assembly.</param>
            <param name="localName">Name of property, local to this type.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FindInheritedEvent(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetType},System.String)">
            <summary>
            Returns the selected event, if it exists in this type.
            </summary>
            <param name="FindType">Function that returns the selected type from all known types in the assembly.</param>
            <param name="localName">Name of event, local to this type.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FindInheritedMethod(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetType},WithoutHaste.DataFiles.DotNet.DotNetQualifiedMethodName)">
            <summary>
            Returns the selected method, if it exists in this type.
            </summary>
            <param name="FindType">Function that returns the selected type from all known types in the assembly.</param>
            <param name="methodName">Name of method, local to this type.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.FindMember(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Returns the specified member from this type of its nested type descendents. Can return a field, property, event, method, delegate, or type.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.AddMember(WithoutHaste.DataFiles.DotNet.DotNetMember)">
            <summary>
            Add a member to this type or one of its nested type descendents.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.AddAssemblyInfo(System.Type,WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Load additional documentation information from the assembly itself for this type or one of its nested type descendents.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.AddAssemblyInfo(System.Type)">
            <summary>
            Load additional information from the assembly for this type.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.PushGenericTypes">
            <summary>
            Push updates to generic-type aliases to all members.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.GetFullListOfLocalNames">
            <summary>
            Collect full list of local names used throughout documentation.
            Includes namespaces, internal types, external types, and members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.ResolveInheritedComments(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetType},System.Collections.Generic.List{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName})">
            <summary>
            For all "inheritdoc" comments, replace the inheritance comment with the inherited comments.
            </summary>
            <remarks>
            Classes can inherit from their base class (or the base class's base, etc).
            Interfaces can inherit from interfaces.
            Class members can inherit from their base class or from interfaces.
            </remarks>
            <param name="FindType">Function that returns the selected type from all known types in the assembly.</param>
            <param name="inheritancePath">List of types or members inheriting from each other, from top level to bottom level. Used to avoid loops.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.ResolveDuplicatedComments(System.Func{WithoutHaste.DataFiles.DotNet.DotNetQualifiedName,WithoutHaste.DataFiles.DotNet.DotNetMember})">
            <summary>
            For all "duplicate" comments, replace the comment with the duplicated comments.
            </summary>
            <param name="FindMember">Function that returns the selected member from all known members in the assembly.</param>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.ToDelegate(WithoutHaste.DataFiles.DotNet.DotNetQualifiedName)">
            <summary>
            Converts the selected type into a delegate, transfering all applicable data.
            </summary>
            <remarks>
            If the <paramref name="name"/> refers to a nested type descendent, that type is the one converted.
            The nested type is removed from its parent and the new delegate is added in its place
            </remarks>
            <param name="name">The fully qualified name of the delegate.</param>
            <returns>The new delegate, or null if the type is not found.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetType.ToString">
            <summary>Returns FullName of type.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.Category">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.ClassName">
            <summary>Strongly-typed name.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.IsSealed">
            <summary>True if the type is sealed.</summary>
            <remarks>Abstract classes, static classes, and interfaces cannot be sealed. Exceptions can be sealed.</remarks>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.BaseType">
            <summary>Base type this type inherits from. Null if not known or none exists.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.NestedTypeCount">
            <summary>The number of types nested within this type, including sub-nested types and enums.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.NestedEnums">
            <summary>The subset of NestedTypes that are enums.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.ConstructorMethods">
            <summary>The subset of Methods that are constructors.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.DestructorMethod">
            <summary>The subset of Methods that are destructors. There can be zero or one destructors.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.OperatorMethods">
            <summary>The subset of Methods that are operator overloads.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.StaticMethods">
            <summary>The subset of Methods that are static (including extension methods), but not constructors, nor destructors, nor operators.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.NormalMethods">
            <summary>The subset of Methods that are not static, nor constructors, nor destructors, nor operators.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.ConstantFields">
            <summary>The subset of Fields that are constants.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.NormalFields">
            <summary>The subset of Fields that are not constant, or where the category is unknown.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.IndexerProperties">
            <summary>The subset of Properties that are indexers.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.NormalProperties">
            <summary>The subset of Properties that are not indexers.</summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetType.AllMembers">
            <summary>
            Lists all methods, delegates, fields, properties, and events.
            Does not include nested types.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.GetAttributeValue(System.Xml.Linq.XElement,System.String)">
            <summary>
            Returns the value of the attribute, or null if the attribute does not exist.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.TrimAllowOneSpace(System.String)">
            <summary>
            Trims leading and trailing whitespaces. Will leave one leading and one trailing space, but won't add them.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.CleanWhitespaces(System.Xml.Linq.XElement)">
            <summary>
            Clean the formatting of all inner xml of an XElement. Returns the cleaned element.
            </summary>
            <remarks>Does not preserve attributes of the root element.</remarks>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.XNodeToString(System.Xml.Linq.XNode)">
            <summary>
            Override NuGet System.Xml.Linq XNode.ToString() which just throws a System.IO.FileNotFoundException.
            </summary>
            <returns>Should return the exact string representation of the node, including the surrounding tags if applicable.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.XElementContentsToString(System.Xml.Linq.XElement)">
            <summary>
            .Net 2.0 compatibility:
            NuGet System.Xml.Linq does not support XNode.ToString() - it just throws a System.IO.FileNotFoundException
            so this is replacing it
            </summary>
            <returns>Should return the exact string contents of the element, with all inner elements converted to strings.</returns>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.TrimFromStartAsBlock(System.String)">
            <summary>
            Trims an equal amount of leading white-space from each line, delimited by \n character.
            Callibrated for formatting blocks of text nested in XML.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.Utilities.TrimFromStartAsLine(System.String)">
            <summary>
            Trims extra whitespace from beginning and end of string. Allows at most one space on each end.
            Callibrated for formatting inline text nested in XML.
            </summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile">
            <summary>
            Represents a .Net XML documentation file, such as those produced by Visual Studio.
            Can add additional documentation derived from the assembly itself.
            </summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.Extensions">
            <summary>Accepted .Net XML documentation file extensions.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.Types">
            <summary>Top-level types in assembly.</summary>
        </member>
        <member name="F:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.Delegates">
            <summary>Top-level delegates in assembly.</summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.#ctor(System.String)">
            <summary>
            Loads .Net XML documentation from file.
            </summary>
            <param name="filename">Full path, filename, and extension.</param>
            <exception cref="T:System.ArgumentException">Filename is null.</exception>
            <exception cref="T:System.ArgumentException">Unexpected file extension of the *.XML documentation file.</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.#ctor(System.Xml.Linq.XDocument)">
            <summary>
            Loads .Net XML documentation from XDocument.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.AddAssemblyInfo(System.String,System.String[])">
            <summary>
            Load additional documentation information from the assembly itself.
            </summary>
            <param name="assemblyFilename">Full path and filename of the *.dll library being documentated.</param>
            <param name="thirdPartyAssemblyFilenames">
            List of third-party libraries referenced by your library.
            These libraries will not be documented, but they must be loaded if you want to see the full type names for return types and parameter types from these libraries.
            Each item in the list should be the full path and filename of a library.
            <example>
            To document the return type of <c>public Company.SomeType MyMethod() {}</c>, the library for <c>Company.SomeType</c> must be loaded.
            </example>
            </param>
            <exception cref="T:WithoutHaste.DataFiles.LoadException">Error loading an assembly.</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.LoadAssembly(System.String)">
            <summary>
            Load assembly, with error handling.
            </summary>
            <exception cref="T:WithoutHaste.DataFiles.LoadException"></exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.GetFullListOfLocalNames">
            <summary>
            Collect full list of local names used throughout documentation.
            Includes namespaces, internal types, external types, and members.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.AssemblyName">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.DataFiles.DotNet.DotNetDocumentationFile.TypeCount">
            <summary>Returns the full count of types within assembly, including nested types and enums.</summary>
        </member>
        <member name="T:WithoutHaste.DataFiles.TextHelper">
            <summary>
            Contains operations for parsing and editing text.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.RemoveFromEnd(System.String,System.String)">
            <summary>
            Removes the <paramref name="end"/> string from the end of <paramref name="text"/>, if it exists there.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.RemoveFromStart(System.String,System.String)">
            <summary>
            Removes the <paramref name="start"/> string from the beginning of <paramref name="text"/>, if it exists there.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.ReplaceUnescapedCharacters(System.String,System.Char,System.Char,System.Char)">
            <summary>
            Replaces all instances of the unescaped <paramref name="searchChar"/> in the <paramref name="text"/>.
            </summary>
            <remarks>
            The <paramref name="escapeChar"/> can escape itself.
            </remarks>
            <example>
              <code>
              string original = "A.B.C\.D\\.E";
              string result = original.ReplaceUnescapedCharacters('\', '.', '_');
              //result = "A_B_C\.D\\_E"
              </code>
            </example>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.CountPreceedingRepeatedChars(System.String,System.Int32,System.Char)">
            <summary>
            Returns the number of sequential characters that all match the selected character, working backwards from the starting index.
            </summary>
            <example>
            ("abcDDDefg", 5, 'D') returns 3 
            ("abcDDDefg", 4, 'D') returns 2 
            </example>
            <param name="text"></param>
            <param name="startIndex">First index checked for <paramref name="searchChar"/>.</param>
            <param name="searchChar"></param>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.RemoveOuterBraces(System.String)">
            <summary>
            Removes outer matched pairs of braces from string.
            Only changes string if first and last characters are a matched pair of braces.
            Supports {}, [], (), and <![CDATA[<>]]>.
            </summary>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.SplitIgnoreNested(System.String,System.Char)">
            <summary>
            Split <paramref name="text"/> on the <paramref name="delimiter"/> 
            but do not split if <paramref name="delimiter"/> is nested within matched braces.
            Supports braces: {}, [], (), and <![CDATA[<>]]>.
            </summary>
            <remarks>
            Returns empty string for empty matches.
            </remarks>
            <example>
            "A,B{c,d},E[f,g,h]".SplitIgnoreNested(",") returns ["A", "B{c,d}", "E[f,g,h]"]
            </example>
            <exception cref="T:System.ArgumentException">Delimitor cannot be a supported brace character.</exception>
            <exception cref="T:WithoutHaste.DataFiles.StringFormatException">Mismatched open/close braces.</exception>
        </member>
        <member name="M:WithoutHaste.DataFiles.TextHelper.IsAllWhitespace(System.String)">
            <summary>
            Returns true if text is empty or contains only whitespace characters.
            </summary>
        </member>
    </members>
</doc>
